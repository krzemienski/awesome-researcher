"""
Planner agent for generating research strategies.
"""

import json
import logging
import random
import time
import traceback
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set

from openai import OpenAI, OpenAIError, APITimeoutError, APIConnectionError, RateLimitError

from awesome_list_researcher.awesome_parser import AwesomeCategory, AwesomeList
from awesome_list_researcher.utils.cost_guard import CostGuard


@dataclass
class ResearchQuery:
    """
    A research query generated by the planner.
    """
    query: str
    category: str
    subcategory: Optional[str] = None

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        result = {
            "query": self.query,
            "category": self.category,
        }
        if self.subcategory:
            result["subcategory"] = self.subcategory
        return result


@dataclass
class ResearchPlan:
    """
    A research plan generated by the planner.
    """
    title: str
    description: str
    queries: List[ResearchQuery] = field(default_factory=list)

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "title": self.title,
            "description": self.description,
            "queries": [query.to_dict() for query in self.queries]
        }

    def to_json(self, indent: int = 2) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=indent)

    @classmethod
    def from_dict(cls, data: Dict) -> 'ResearchPlan':
        """Create from dictionary."""
        plan = cls(
            title=data["title"],
            description=data["description"]
        )

        for query_data in data.get("queries", []):
            plan.queries.append(ResearchQuery(
                query=query_data["query"],
                category=query_data["category"],
                subcategory=query_data.get("subcategory")
            ))

        return plan

    @classmethod
    def from_json(cls, json_str: str) -> 'ResearchPlan':
        """Create from JSON string."""
        data = json.loads(json_str)
        return cls.from_dict(data)


class PlannerAgent:
    """
    Agent for planning research queries based on the contents of an Awesome list.
    """

    SYSTEM_PROMPT = """You are a research planning assistant tasked with generating search queries to find new resources for an Awesome List.

You will be given a JSON representation of an existing Awesome List, containing categories and links to resources.
Your goal is to create a set of search queries that will help discover NEW, HIGH-QUALITY resources in each category that are not already in the list.

For each category and subcategory, generate 2-3 diverse search queries that:
1. Target the specific domain/technology of that category
2. Include terms like "best", "popular", "awesome", "useful", "essential", "top"
3. Vary between general and specific approaches
4. Include the current year to find recent resources

Your response should be a JSON object with the following structure:
{
  "title": "Research Plan for [LIST TITLE]",
  "description": "A plan to discover new resources for [LIST DESCRIPTION]",
  "queries": [
    {
      "query": "search query text",
      "category": "category name",
      "subcategory": "subcategory name" // optional
    },
    // More queries...
  ]
}

Focus on generating diverse, non-redundant queries that will yield different results when used with search engines.
"""

    def __init__(
        self,
        model: str,
        api_client: OpenAI,
        cost_guard: CostGuard,
        logger: logging.Logger,
        seed: Optional[int] = None
    ):
        """
        Initialize the planner agent.

        Args:
            model: OpenAI model to use
            api_client: OpenAI API client
            cost_guard: Cost guard for tracking API usage
            logger: Logger instance
            seed: Random seed for deterministic query shuffling (optional)
        """
        self.model = model
        self.api_client = api_client
        self.cost_guard = cost_guard
        self.logger = logger

        # Set random seed if provided
        if seed is not None:
            random.seed(seed)

    def generate_plan(
        self,
        awesome_list: AwesomeList,
        max_queries_per_category: int = 3
    ) -> ResearchPlan:
        """
        Generate a research plan from an Awesome list.

        Args:
            awesome_list: Parsed Awesome list
            max_queries_per_category: Maximum number of queries per category

        Returns:
            ResearchPlan object
        """
        self.logger.info(
            f"Generating research plan for '{awesome_list.title}' using model {self.model}"
        )

        # Log the actual list data
        self.logger.info(f"Awesome list contains {len(awesome_list.categories)} categories")
        for category in awesome_list.categories:
            self.logger.info(f"Category: {category.name} - {len(category.links)} direct links, {sum(len(links) for links in category.subcategories.values())} subcategory links")

        # Convert the awesome list to JSON for the prompt
        awesome_list_json = awesome_list.to_json()

        # Log the size of the JSON
        self.logger.info(f"Awesome list JSON size: {len(awesome_list_json)} characters")

        # Prepare the prompt
        prompt = f"Please analyze this Awesome List and generate search queries:\n\n{awesome_list_json}"

        # Check if the API call would exceed the cost ceiling
        input_tokens = len(prompt.split()) * 1.5  # Rough estimate
        self.logger.info(f"Estimated input tokens: {input_tokens}")

        if self.cost_guard.would_exceed_ceiling(self.model, int(input_tokens)):
            self.logger.error("Cost ceiling would be exceeded by planner agent call")
            raise ValueError("Cost ceiling would be exceeded")

        # Log the system prompt and user prompt (truncated for brevity)
        self.logger.info(f"System prompt (first 200 chars): {self.SYSTEM_PROMPT[:200]}...")
        self.logger.info(f"User prompt (first 200 chars): {prompt[:200]}...")

        # Create messages for API call
        messages = [
            {"role": "system", "content": self.SYSTEM_PROMPT},
            {"role": "user", "content": prompt}
        ]

        # Make the API call
        self.logger.info(f"Making OpenAI API call with model {self.model}")
        start_time = time.time()
        try:
            self.logger.info("Sending request to OpenAI API...")
            response = self.api_client.chat.completions.create(
                model=self.model,
                messages=messages,
                response_format={"type": "json_object"},
                timeout=180  # Increase timeout to 3 minutes
            )
            end_time = time.time()
            elapsed_time = end_time - start_time
            self.logger.info(f"Received response from OpenAI API after {elapsed_time:.2f} seconds")

            # Track usage
            usage = response.usage
            self.logger.info(f"API usage - Input tokens: {usage.prompt_tokens}, Output tokens: {usage.completion_tokens}, Total tokens: {usage.total_tokens}")

            self.cost_guard.update_usage(
                model=self.model,
                input_tokens=usage.prompt_tokens,
                output_tokens=usage.completion_tokens,
                event="planner_agent_call"
            )

            # Parse the response
            response_content = response.choices[0].message.content
            self.logger.info(f"Response length: {len(response_content)} characters")
            self.logger.info(f"Response preview (first 300 chars): {response_content[:300]}...")

            try:
                self.logger.info("Parsing JSON response")
                plan_data = json.loads(response_content)
                self.logger.info(f"JSON parsed successfully with keys: {list(plan_data.keys())}")

                # Create the research plan
                plan = ResearchPlan(
                    title=plan_data.get("title", f"Research Plan for {awesome_list.title}"),
                    description=plan_data.get("description", "")
                )

                # Add queries with a limit per category
                category_query_counts: Dict[str, int] = {}

                # Randomize the order of queries
                queries_data = plan_data.get("queries", [])
                self.logger.info(f"Received {len(queries_data)} queries in response")

                # Log a few sample queries
                if queries_data:
                    self.logger.info("Sample queries:")
                    for i, q in enumerate(queries_data[:3]):  # Log first 3 queries as samples
                        self.logger.info(f"  Query {i+1}: {q.get('query', 'N/A')} - Category: {q.get('category', 'N/A')}")

                random.shuffle(queries_data)

                for query_data in queries_data:
                    category = query_data.get("category", "")
                    subcategory = query_data.get("subcategory")

                    # Skip if we've reached the limit for this category
                    category_key = f"{category}:{subcategory}" if subcategory else category
                    current_count = category_query_counts.get(category_key, 0)

                    if current_count >= max_queries_per_category:
                        continue

                    # Add the query
                    plan.queries.append(ResearchQuery(
                        query=query_data["query"],
                        category=category,
                        subcategory=subcategory
                    ))

                    # Update the count
                    category_query_counts[category_key] = current_count + 1

                self.logger.info(
                    f"Generated research plan with {len(plan.queries)} queries across {len(category_query_counts)} categories/subcategories"
                )

                return plan

            except (json.JSONDecodeError, KeyError) as e:
                self.logger.error(f"Failed to parse planner response: {str(e)}")
                self.logger.error(f"Response content (first 500 chars): {response_content[:500]}...")
                raise ValueError(f"Invalid response from planner agent: {str(e)}")

        except APITimeoutError as e:
            self.logger.error(f"OpenAI API timeout after {time.time() - start_time:.2f} seconds: {str(e)}")
            raise ValueError(f"OpenAI API timeout: {str(e)}")
        except RateLimitError as e:
            self.logger.error(f"OpenAI API rate limit exceeded: {str(e)}")
            raise ValueError(f"OpenAI API rate limit exceeded: {str(e)}")
        except APIConnectionError as e:
            self.logger.error(f"OpenAI API connection error: {str(e)}")
            raise ValueError(f"OpenAI API connection error: {str(e)}")
        except OpenAIError as e:
            self.logger.error(f"OpenAI API error: {str(e)}")
            raise ValueError(f"OpenAI API error: {str(e)}")
        except Exception as e:
            self.logger.error(f"Error calling planner agent: {str(e)}")
            self.logger.error(f"Exception details: {traceback.format_exc()}")
            raise
